"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const utils_1 = require("ssb-typescript/utils");
const secret_stack_decorators_1 = require("secret-stack-decorators");
const pull = require('pull-stream');
const cat = require('pull-cat');
const sort = require('ssb-sort');
const Ref = require('ssb-ref');
const { where, and, or, not, type, author, descending, live, isPrivate, isPublic, hasRoot, hasFork, paginate, toPullStream, } = require('ssb-db2/operators');
const IS_BLOCKING_NEVER = (obj, cb) => {
    cb(null, false);
};
/**
 * 50 msgs kept in memory is rather small (~24kB), but this is large enough to
 * have good performance in JITDB pagination, see https://github.com/ssb-ngi-pointer/jitdb/pull/123#issuecomment-782734363
 */
const PAGESIZE = 50;
function getTimestamp(msg) {
    const arrivalTimestamp = msg.timestamp;
    const declaredTimestamp = msg.value.timestamp;
    return Math.min(arrivalTimestamp, declaredTimestamp);
}
function getRootMsgId(msg) {
    var _a;
    if ((_a = msg === null || msg === void 0 ? void 0 : msg.value) === null || _a === void 0 ? void 0 : _a.content) {
        const fork = msg.value.content.fork;
        const root = msg.value.content.root;
        if (fork && Ref.isMsgId(fork))
            return fork;
        if (root && Ref.isMsgId(root))
            return root;
    }
    // this msg has no root so we assume this is a root
    return msg.key;
}
function isUniqueMsgId(uniqueRoots) {
    return function checkIsUnique_id(id) {
        if (uniqueRoots.has(id)) {
            return false;
        }
        else {
            uniqueRoots.add(id);
            return true;
        }
    };
}
function hasNoBacklinks(msg) {
    var _a, _b, _c, _d, _e, _f;
    return (!((_b = (_a = msg === null || msg === void 0 ? void 0 : msg.value) === null || _a === void 0 ? void 0 : _a.content) === null || _b === void 0 ? void 0 : _b.root) &&
        !((_d = (_c = msg === null || msg === void 0 ? void 0 : msg.value) === null || _c === void 0 ? void 0 : _c.content) === null || _d === void 0 ? void 0 : _d.branch) &&
        !((_f = (_e = msg === null || msg === void 0 ? void 0 : msg.value) === null || _e === void 0 ? void 0 : _e.content) === null || _f === void 0 ? void 0 : _f.fork));
}
function makeFilterOperator(opts) {
    if (opts.allowlist) {
        const allowedTypes = opts.allowlist.map(type);
        return or(...allowedTypes);
    }
    if (opts.blocklist) {
        const blockedTypes = opts.blocklist.map((x) => not(type(x)));
        return and(...blockedTypes);
    }
    return null;
}
function makePassesFilter(opts) {
    if (opts.allowlist) {
        return (msg) => opts.allowlist.some((type) => { var _a, _b; return ((_b = (_a = msg === null || msg === void 0 ? void 0 : msg.value) === null || _a === void 0 ? void 0 : _a.content) === null || _b === void 0 ? void 0 : _b.type) === type; });
    }
    if (opts.blocklist) {
        return (msg) => opts.blocklist.every((type) => { var _a, _b; return ((_b = (_a = msg === null || msg === void 0 ? void 0 : msg.value) === null || _a === void 0 ? void 0 : _a.content) === null || _b === void 0 ? void 0 : _b.type) !== type; });
    }
    return () => true;
}
let threads = class threads {
    constructor(ssb, _config) {
        var _a;
        //#region PRIVATE
        this.removeMessagesFromBlocked = (source) => pull(source, pull.asyncMap((msg, cb) => {
            this.isBlocking({ source: this.ssb.id, dest: msg.value.author }, (err, blocking) => {
                if (err)
                    cb(err);
                else if (blocking)
                    cb(null, null);
                else
                    cb(null, msg);
            });
        }), pull.filter());
        this.nonBlockedRootToThread = (maxSize, filter, privately = false) => {
            return (root, cb) => {
                pull(cat([
                    pull.values([root]),
                    pull(this.ssb.db.query(where(and(hasRoot(root.key), filter, privately ? isPrivate() : isPublic())), paginate(PAGESIZE), descending(), toPullStream()), pull.map(pull.values), pull.flatten(), this.removeMessagesFromBlocked, pull.take(maxSize)),
                ]), pull.take(maxSize + 1), pull.collect((err2, arr) => {
                    if (err2)
                        return cb(err2);
                    const full = arr.length <= maxSize;
                    sort(arr);
                    if (arr.length > maxSize && arr.length >= 3)
                        arr.splice(1, 1);
                    cb(null, { messages: arr, full });
                }));
            };
        };
        this.nonBlockedRootToSummary = (filter, timestamps) => {
            return (root, cb) => {
                pull(this.ssb.db.query(where(and(or(hasRoot(root.key), hasFork(root.key)), filter)), paginate(PAGESIZE), descending(), toPullStream()), pull.map(pull.values), pull.flatten(), this.removeMessagesFromBlocked, pull.collect((err2, arr) => {
                    var _a;
                    if (err2)
                        return cb(err2);
                    const timestamp = (_a = timestamps.get(root.key)) !== null && _a !== void 0 ? _a : root.timestamp;
                    cb(null, { root, replyCount: arr.length, timestamp });
                }));
            };
        };
        /**
         * Returns a pull-stream operator that:
         * 1. Checks if there is a Msg in the cache for the source MsgId
         * 2. If not in the cache, do a database lookup
         */
        this.fetchMsgFromIdIfItExists = (source) => pull(source, pull.asyncMap((id, cb) => {
            this.ssb.db.getMsg(id, (err, msg) => {
                if (err)
                    cb(null, null /* missing msg */);
                else
                    cb(err, msg);
            });
        }), pull.filter());
        this.rootToThread = (maxSize, filter, privately) => {
            return pull.asyncMap((root, cb) => {
                this.isBlocking({ source: this.ssb.id, dest: root.value.author }, (err, blocking) => {
                    if (err) {
                        cb(err);
                    }
                    else if (blocking) {
                        cb(new Error('Author Blocked:' + root.value.author));
                    }
                    else {
                        this.nonBlockedRootToThread(maxSize, filter, privately)(root, cb);
                    }
                });
            });
        };
        //#endregion
        //#region PUBLIC API
        this.public = (opts) => {
            var _a, _b;
            const needsDescending = (_a = opts.reverse) !== null && _a !== void 0 ? _a : true;
            const threadMaxSize = (_b = opts.threadMaxSize) !== null && _b !== void 0 ? _b : Infinity;
            const filterOperator = makeFilterOperator(opts);
            const passesFilter = makePassesFilter(opts);
            return pull(this.ssb.db.query(where(and(isPublic(), filterOperator)), needsDescending ? descending() : null, paginate(PAGESIZE), toPullStream()), pull.map(pull.values), pull.flatten(), pull.map(getRootMsgId), pull.filter(isUniqueMsgId(new Set())), this.fetchMsgFromIdIfItExists, pull.filter(passesFilter), pull.filter(utils_1.isPublic), pull.filter(hasNoBacklinks), this.removeMessagesFromBlocked, pull.asyncMap(this.nonBlockedRootToThread(threadMaxSize, filterOperator)));
        };
        this.publicSummary = (opts) => {
            var _a;
            const needsDescending = (_a = opts.reverse) !== null && _a !== void 0 ? _a : true;
            const filterOperator = makeFilterOperator(opts);
            const passesFilter = makePassesFilter(opts);
            const timestamps = new Map();
            return pull(this.ssb.db.query(where(and(isPublic(), filterOperator)), needsDescending ? descending() : null, paginate(PAGESIZE), toPullStream()), pull.map(pull.values), pull.flatten(), pull.through((msg) => timestamps.set(getRootMsgId(msg), getTimestamp(msg))), pull.map(getRootMsgId), pull.filter(isUniqueMsgId(new Set())), this.fetchMsgFromIdIfItExists, pull.filter(passesFilter), pull.filter(utils_1.isPublic), pull.filter(hasNoBacklinks), this.removeMessagesFromBlocked, pull.asyncMap(this.nonBlockedRootToSummary(filterOperator, timestamps)));
        };
        this.publicUpdates = (opts) => {
            var _a;
            const filterOperator = makeFilterOperator(opts);
            const passesFilter = makePassesFilter(opts);
            const includeSelf = (_a = opts.includeSelf) !== null && _a !== void 0 ? _a : false;
            return pull(this.ssb.db.query(where(and(isPublic(), filterOperator, includeSelf ? null : not(author(this.ssb.id, { dedicated: true })))), live({ old: false }), toPullStream()), pull.filter(passesFilter), this.removeMessagesFromBlocked, pull.map((msg) => msg.key));
        };
        this.private = (opts) => {
            var _a, _b;
            const needsDescending = (_a = opts.reverse) !== null && _a !== void 0 ? _a : true;
            const threadMaxSize = (_b = opts.threadMaxSize) !== null && _b !== void 0 ? _b : Infinity;
            const filterOperator = makeFilterOperator(opts);
            const passesFilter = makePassesFilter(opts);
            return pull(this.ssb.db.query(where(and(isPrivate(), filterOperator)), needsDescending ? descending() : null, paginate(PAGESIZE), toPullStream()), pull.map(pull.values), pull.flatten(), pull.map(getRootMsgId), pull.filter(isUniqueMsgId(new Set())), this.fetchMsgFromIdIfItExists, pull.filter(passesFilter), pull.filter(utils_1.isPrivate), pull.filter(hasNoBacklinks), this.removeMessagesFromBlocked, pull.asyncMap(this.nonBlockedRootToThread(threadMaxSize, filterOperator, true)));
        };
        this.privateUpdates = (opts) => {
            var _a;
            const filterOperator = makeFilterOperator(opts);
            const includeSelf = (_a = opts.includeSelf) !== null && _a !== void 0 ? _a : false;
            return pull(this.ssb.db.query(where(and(isPrivate(), filterOperator, includeSelf ? null : not(author(this.ssb.id, { dedicated: true })))), live({ old: false }), toPullStream()), this.removeMessagesFromBlocked, pull.map(getRootMsgId));
        };
        this.profile = (opts) => {
            var _a, _b;
            const id = opts.id;
            const needsDescending = (_a = opts.reverse) !== null && _a !== void 0 ? _a : true;
            const threadMaxSize = (_b = opts.threadMaxSize) !== null && _b !== void 0 ? _b : Infinity;
            const filterOperator = makeFilterOperator(opts);
            const passesFilter = makePassesFilter(opts);
            return pull(this.ssb.db.query(where(and(author(id), isPublic(), filterOperator)), needsDescending ? descending() : null, paginate(PAGESIZE), toPullStream()), pull.map(pull.values), pull.flatten(), pull.map(getRootMsgId), pull.filter(isUniqueMsgId(new Set())), this.fetchMsgFromIdIfItExists, pull.filter(passesFilter), pull.filter(utils_1.isPublic), this.removeMessagesFromBlocked, pull.asyncMap(this.nonBlockedRootToThread(threadMaxSize, filterOperator)));
        };
        this.profileSummary = (opts) => {
            var _a;
            const id = opts.id;
            const needsDescending = (_a = opts.reverse) !== null && _a !== void 0 ? _a : true;
            const filterOperator = makeFilterOperator(opts);
            const passesFilter = makePassesFilter(opts);
            const timestamps = new Map();
            return pull(this.ssb.db.query(where(and(author(id), isPublic(), filterOperator)), needsDescending ? descending() : null, paginate(PAGESIZE), toPullStream()), pull.map(pull.values), pull.flatten(), pull.through((msg) => timestamps.set(getRootMsgId(msg), getTimestamp(msg))), pull.map(getRootMsgId), pull.filter(isUniqueMsgId(new Set())), this.fetchMsgFromIdIfItExists, pull.filter(passesFilter), pull.filter(utils_1.isPublic), pull.filter(hasNoBacklinks), this.removeMessagesFromBlocked, pull.asyncMap(this.nonBlockedRootToSummary(filterOperator, timestamps)));
        };
        this.thread = (opts) => {
            var _a;
            const privately = !!opts.private;
            const threadMaxSize = (_a = opts.threadMaxSize) !== null && _a !== void 0 ? _a : Infinity;
            const optsOk = !opts.allowlist && !opts.blocklist
                ? { ...opts, allowlist: ['post'] }
                : opts;
            const filterOperator = makeFilterOperator(optsOk);
            return pull(pull.values([opts.root]), this.fetchMsgFromIdIfItExists, privately ? pull.through() : pull.filter(utils_1.isPublic), this.rootToThread(threadMaxSize, filterOperator, privately));
        };
        this.threadUpdates = (opts) => {
            const privately = !!opts.private;
            const filterOperator = makeFilterOperator(opts);
            return pull(this.ssb.db.query(where(and(hasRoot(opts.root), filterOperator, privately ? isPrivate() : isPublic())), live({ old: false }), toPullStream()), this.removeMessagesFromBlocked);
        };
        this.ssb = ssb;
        this.isBlocking = ((_a = ssb.friends) === null || _a === void 0 ? void 0 : _a.isBlocking)
            ? ssb.friends.isBlocking
            : IS_BLOCKING_NEVER;
    }
};
__decorate([
    secret_stack_decorators_1.muxrpc('source')
], threads.prototype, "public", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('source')
], threads.prototype, "publicSummary", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('source')
], threads.prototype, "publicUpdates", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('source')
], threads.prototype, "private", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('source')
], threads.prototype, "privateUpdates", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('source')
], threads.prototype, "profile", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('source')
], threads.prototype, "profileSummary", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('source')
], threads.prototype, "thread", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('source')
], threads.prototype, "threadUpdates", void 0);
threads = __decorate([
    secret_stack_decorators_1.plugin('2.0.0')
], threads);
module.exports = threads;
//# sourceMappingURL=index.js.map