"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const debug = require('debug')('ssb:room-client');
const pull = require('pull-stream');
const Ref = require('ssb-ref');
const run = require("promisify-tuple");
const room_observer_1 = require("./room-observer");
const utils_1 = require("./utils");
exports.default = (rooms, ssb) => (msConfig) => {
    const self = {
        name: 'tunnel',
        scope() {
            return msConfig.scope;
        },
        server(onConnect, startedCB) {
            pull(ssb.conn.hub().listen(), pull.filter(({ type }) => type === 'connected'), pull.drain(async ({ address, key, details }) => {
                if (!key)
                    return;
                if (rooms.has(key))
                    return;
                if (!(details === null || details === void 0 ? void 0 : details.rpc))
                    return;
                if (address.startsWith('tunnel:'))
                    return;
                const rpc = details.rpc;
                debug('will try to call room.metadata() on the peer %s', key);
                var [err, res] = await run(rpc.room.metadata)();
                if (utils_1.muxrpcMissing(err)) {
                    debug('will try to call tunnel.isRoom() on the peer %s', key);
                    [err, res] = await run(rpc.tunnel.isRoom)();
                    if (!err && res && typeof res === 'object')
                        res._isRoom1 = true;
                }
                if (err || !res)
                    return;
                debug('is connected to an actual ssb-room');
                if (rooms.has(key)) {
                    rooms.get(key).cancel();
                    rooms.delete(key);
                }
                const obs = new room_observer_1.default(ssb, key, address, rpc, res, onConnect);
                rooms.set(key, obs);
            }));
            pull(ssb.conn.hub().listen(), pull.filter(({ type }) => type === 'disconnected'), pull.drain(({ key }) => {
                if (!key)
                    return;
                if (!rooms.has(key))
                    return;
                rooms.get(key).close();
                rooms.delete(key);
            }));
            startedCB();
            return () => {
                rooms.forEach((roomObserver) => {
                    roomObserver.close();
                });
                rooms.clear();
            };
        },
        async client(addr, cb) {
            var _a, _b;
            debug(`we wish to connect to %o`, addr);
            const opts = self.parse(addr);
            if (!opts) {
                cb(new Error(`invalid tunnel address ${addr}`));
                return;
            }
            const { portal, target } = opts;
            const addrStr = JSON.stringify(addr);
            let roomRPC = null;
            if (rooms.has(portal)) {
                roomRPC = rooms.get(portal).rpc;
            }
            if (!roomRPC) {
                for (const [msaddr] of ssb.conn.db().entries()) {
                    const key = Ref.getKeyFromAddress(msaddr);
                    if (key === portal) {
                        debug(`to connect to ${addrStr} we first have to connect to ${portal}`);
                        const [err, rpc] = await run(ssb.conn.connect)(msaddr);
                        if (err) {
                            cb(new Error((_a = `cant connect to ${addrStr} because ` +
                                `cant reach the room ${portal} due to: ` +
                                err.message) !== null && _a !== void 0 ? _a : err));
                            return;
                        }
                        roomRPC = rpc;
                    }
                }
            }
            if (!roomRPC) {
                const addrPlusShs = utils_1.toTunnelAddress(portal, target);
                const peerData = ssb.conn.db().get(addrPlusShs);
                if ((peerData === null || peerData === void 0 ? void 0 : peerData.room) === portal && (peerData === null || peerData === void 0 ? void 0 : peerData.roomAddress)) {
                    debug(`to connect to ${addrStr} we first have to connect to ${portal}`);
                    const [err, rpc] = await run(ssb.conn.connect)(peerData.roomAddress);
                    if (err) {
                        cb(new Error((_b = `cant connect to ${addrStr} because ` +
                            `cant reach the room ${portal} due to: ` +
                            err.message) !== null && _b !== void 0 ? _b : err));
                        return;
                    }
                    roomRPC = rpc;
                }
            }
            if (!roomRPC) {
                cb(new Error(`cant connect to ${addrStr} because ` +
                    `room ${portal} is offline or unknown`));
                return;
            }
            debug(`will call tunnel.connect at ${target} via room ${portal}`);
            const duplex = roomRPC.tunnel.connect({ target, portal }, (err) => {
                var _a;
                if (err) {
                    debug('tunnel duplex broken with %o because %s', addr, (_a = err.message) !== null && _a !== void 0 ? _a : err);
                }
            });
            cb(null, duplex);
        },
        parse(addr) {
            let opts;
            if (typeof addr === 'object') {
                opts = addr;
            }
            else {
                const [name, portal, target] = addr.split(':');
                if (name !== 'tunnel')
                    return;
                opts = { name, portal, target };
            }
            if (!Ref.isFeed(opts.portal))
                return;
            if (!Ref.isFeed(opts.target))
                return;
            return opts;
        },
        stringify() {
            return undefined;
        },
    };
    return self;
};
