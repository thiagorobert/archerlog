"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("./utils");
const debug = require('debug')('ssb:room-client');
const pull = require('pull-stream');
const getSeverity = require('ssb-network-errors');
class RoomObserver {
    constructor(ssb, serverKey, address, rpc, roomMetadata, onConnect) {
        this.attendantsUpdated = (event) => {
            const room = this.roomKey;
            const roomName = typeof this.roomMetadata === 'object' ? this.roomMetadata.name : void 0;
            if (event.type === 'state') {
                debug('initial attendants in %s: %s', room, JSON.stringify(event.ids));
            }
            else if (event.type === 'joined') {
                debug('attendant joined %s: %s', room, event.id);
            }
            else if (event.type === 'left') {
                debug('attendant left %s: %s', room, event.id);
            }
            if (event.type === 'state') {
                this.attendants.clear();
                for (const key of event.ids) {
                    this.attendants.add(key);
                }
            }
            else if (event.type === 'joined') {
                this.attendants.add(event.id);
            }
            else if (event.type === 'left') {
                this.attendants.delete(event.id);
            }
            const onlineCount = this.attendants.size;
            this.ssb.conn.hub().update(this.address, { onlineCount });
            if (event.type === 'state') {
                for (const id of event.ids) {
                    this.stageNewAttendant(id, room, roomName);
                }
            }
            else if (event.type === 'joined') {
                this.stageNewAttendant(event.id, room, roomName);
            }
            else if (event.type === 'left') {
                const address = this.getAddress(event.id);
                debug('will conn.unstage("%s")', address);
                this.ssb.conn.unstage(address);
            }
        };
        this.attendantsEnded = (err) => {
            if (err && err !== true) {
                if (utils_1.muxrpcMissing(err)) {
                    this.attendantsDrain = void 0;
                    this.startEndpoints();
                    return;
                }
                this.handleStreamError(err);
            }
        };
        this.endpointsUpdated = (endpoints) => {
            const room = this.roomKey;
            const roomName = typeof this.roomMetadata === 'object' ? this.roomMetadata.name : void 0;
            debug('got endpoints from %s: %s', room, JSON.stringify(endpoints));
            const onlineCount = endpoints.length;
            this.ssb.conn.hub().update(this.address, { onlineCount });
            for (const entry of this.ssb.conn.staging().entries()) {
                const [addr, data] = entry;
                if (data.room === room && data.key && !endpoints.includes(data.key)) {
                    debug('will conn.unstage("%s")', addr);
                    this.ssb.conn.unstage(addr);
                }
            }
            for (const key of endpoints) {
                this.stageNewAttendant(key, room, roomName);
            }
        };
        this.endpointsEnded = (err) => {
            if (err && err !== true) {
                this.handleStreamError(err);
            }
        };
        this.ssb = ssb;
        this.roomKey = serverKey;
        this.address = address;
        this.rpc = rpc;
        this.roomMetadata = roomMetadata;
        this.attendants = new Set();
        this.handler = (stream, id) => {
            stream.address = `tunnel:${this.roomKey}:${id}`;
            debug('handler will call onConnect for the stream.address: %s', stream.address);
            onConnect(stream);
        };
        if (typeof this.roomMetadata === 'object' &&
            this.roomMetadata &&
            Object.keys(this.roomMetadata).length >= 1) {
            const metadata = { type: 'room' };
            const { name, membership, features, _isRoom1 } = this.roomMetadata;
            if (name)
                metadata.name = name;
            if (membership)
                metadata.membership = true;
            if (_isRoom1)
                metadata.openInvites = true;
            if (Array.isArray(features)) {
                if (features.includes('room1'))
                    metadata.openInvites = true;
                if (features.includes('room2'))
                    metadata.supportsRoom2 = true;
                if (features.includes('alias'))
                    metadata.supportsAliases = true;
                if (features.includes('httpAuth'))
                    metadata.supportsHttpAuth = true;
                if (features.includes('httpInvite'))
                    metadata.supportsHttpInvite = true;
            }
            this.ssb.conn.db().update(this.address, metadata);
            this.ssb.conn.hub().update(this.address, metadata);
        }
        debug('announcing to portal: %s', this.roomKey);
        this.startAttendants();
    }
    startAttendants() {
        pull(this.rpc.room.attendants(), (this.attendantsDrain = pull.drain(this.attendantsUpdated, this.attendantsEnded)));
    }
    startEndpoints() {
        pull(this.rpc.tunnel.endpoints(), (this.endpointsDrain = pull.drain(this.endpointsUpdated, this.endpointsEnded)));
    }
    stageNewAttendant(key, room, roomName) {
        if (key === room)
            return;
        if (key === this.ssb.id)
            return;
        if (this.isAlreadyConnected(key))
            return;
        const address = this.getAddress(key);
        debug('will conn.stage("%s")', address);
        this.ssb.conn.stage(address, {
            type: 'room-attendant',
            key,
            room,
            roomName,
        });
    }
    handleStreamError(err) {
        const severity = getSeverity(err);
        if (severity === 1) {
            this.close();
        }
        else if (severity >= 2) {
            console.error(`error getting updates from room ${this.roomKey} because ${err.message}`);
        }
    }
    isAlreadyConnected(key) {
        for (const [, data] of this.ssb.conn.hub().entries()) {
            if (data.key === key)
                return true;
        }
        return false;
    }
    getAddress(key) {
        const shs = key.substr(1, key.length - 9);
        return `tunnel:${this.roomKey}:${key}~shs:${shs}`;
    }
    cancel() {
        var _a, _b;
        (_a = this.attendantsDrain) === null || _a === void 0 ? void 0 : _a.abort();
        (_b = this.endpointsDrain) === null || _b === void 0 ? void 0 : _b.abort();
    }
    close() {
        var _a, _b;
        (_a = this.attendantsDrain) === null || _a === void 0 ? void 0 : _a.abort();
        (_b = this.endpointsDrain) === null || _b === void 0 ? void 0 : _b.abort();
        for (const key of this.attendants) {
            const address = this.getAddress(key);
            this.ssb.conn.unstage(address);
        }
        for (const [addr, data] of this.ssb.conn.staging().entries()) {
            if (data.room === this.roomKey) {
                this.ssb.conn.unstage(addr);
            }
        }
        this.rpc.close(true, (err) => {
            if (err)
                debug('error when closing connection with room: %o', err);
        });
        this.ssb.conn.disconnect(this.address, () => { });
    }
}
exports.default = RoomObserver;
