"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const debug = require('debug')('ssb:room-client');
const DuplexPair = require('pull-pair/duplex');
const error_duplex_1 = require("./error-duplex");
const ms_tunnel_1 = require("./ms-tunnel");
function hasConnInstalled(ssb) {
    var _a;
    return !!((_a = ssb.conn) === null || _a === void 0 ? void 0 : _a.connect);
}
module.exports = {
    name: 'tunnel',
    version: '1.0.0',
    manifest: {
        connect: 'duplex',
        ping: 'sync',
        announce: 'sync',
        leave: 'sync',
        endpoints: 'source',
        isRoom: 'async',
    },
    permissions: {
        anonymous: { allow: ['connect', 'ping'] },
    },
    init(ssb) {
        if (!hasConnInstalled(ssb)) {
            throw new Error('ssb-room-client plugin requires the ssb-conn plugin');
        }
        const rooms = new Map();
        ssb.multiserver.transport({
            name: 'tunnel',
            create: ms_tunnel_1.default(rooms, ssb),
        });
        return {
            connect(opts) {
                if (!opts)
                    return error_duplex_1.default('opts *must* be provided');
                debug('received incoming tunnel.connect(%o)', opts);
                const { target, portal, origin } = opts;
                if (target === ssb.id && rooms.has(portal)) {
                    debug('connect() will resolve because handler exists');
                    const handler = rooms.get(portal).handler;
                    const [ins, outs] = DuplexPair();
                    handler(ins, origin !== null && origin !== void 0 ? origin : this.id);
                    return outs;
                }
                else {
                    return error_duplex_1.default(`could not connect to ${target}`);
                }
            },
            ping() {
                return Date.now();
            },
            getRoomsMap() {
                return rooms;
            }
        };
    },
};
