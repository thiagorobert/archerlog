"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Ref = require('ssb-ref');
const ssbKeys = require('ssb-keys');
const run = require("promisify-tuple");
const minireq = typeof window !== 'undefined'
    ? require('@minireq/browser').makeRequest()
    : require('@minireq/node').makeRequest();
function sleep(period) {
    return new Promise((resolve) => {
        setTimeout(resolve, period, null);
    });
}
const ALIAS_URI_ACTION = 'consume-alias';
function aliasRegistrationStr(roomId, userId, alias) {
    return `=room-alias-registration:${roomId}:${userId}:${alias}`;
}
module.exports = {
    name: 'roomClient',
    version: '1.0.0',
    manifest: {
        consumeAliasUri: 'async',
        registerAlias: 'async',
        revokeAlias: 'async',
    },
    permissions: {
        anonymous: {},
    },
    init(ssb, config) {
        if (!ssb.tunnel.getRoomsMap)
            throw new Error('missing tunnel plugin');
        function jsonResponseFailed(data) {
            return (typeof data.status === 'string' &&
                data.status !== 'successful' &&
                data.error);
        }
        async function consumeAlias(opts, cb) {
            var _a, _b;
            if (!Ref.isAddress(opts.multiserverAddress)) {
                cb(new Error(`bad multiserverAddress: ${opts.multiserverAddress}`));
                return;
            }
            if (!Ref.isFeed(opts.roomId)) {
                cb(new Error(`bad roomId: ${opts.roomId}`));
                return;
            }
            if (!Ref.isFeed(opts.userId)) {
                cb(new Error(`bad userId: ${opts.userId}`));
                return;
            }
            if (!opts.alias || typeof opts.alias !== 'string') {
                cb(new Error(`bad alias: ${opts.alias}`));
                return;
            }
            if (!opts.signature || typeof opts.signature !== 'string') {
                cb(new Error(`bad signature: ${opts.signature}`));
                return;
            }
            const { multiserverAddress, roomId, userId, alias, signature } = opts;
            const roomAddress = multiserverAddress;
            const sig = signature.replace(/_/g, '/').replace(/-/g, '+');
            const body = aliasRegistrationStr(roomId, userId, alias);
            const ok = ssbKeys.verify(userId, sig, body);
            if (!ok) {
                cb(new Error(`cannot consumeAlias because the signature is wrong`));
                return;
            }
            const rooms = ssb.tunnel.getRoomsMap();
            const [err] = await run(ssb.conn.connect)(roomAddress);
            if (err) {
                cb(new Error((_a = `cannot consumeAlias ${alias} because ` +
                    `cannot connect to room ${roomId} due to: ` +
                    err.message) !== null && _a !== void 0 ? _a : err));
                return;
            }
            let period = 32;
            while (!rooms.has(roomId)) {
                if (period < 8000) {
                    await sleep((period = period * 2));
                }
                else {
                    cb(new Error(`cannot consumeAlias ${alias} because room ${roomId} ` +
                        `is missing from our internal cache`));
                    return;
                }
            }
            const roomData = ssb.conn.db().get(roomAddress);
            const haveMembershipHere = roomData === null || roomData === void 0 ? void 0 : roomData.membership;
            const isForeignRoom = !roomData;
            let connectedToOtherAttendants = false;
            for (const [, data] of ssb.conn.hub().entries()) {
                if (data.room === roomId) {
                    connectedToOtherAttendants = true;
                    break;
                }
            }
            const shs = userId.slice(1, -8);
            const tunnelAddr = `tunnel:${roomId}:${userId}~shs:${shs}`;
            const [err2, aliasRpc] = await run(ssb.conn.connect)(tunnelAddr);
            if (err2) {
                cb(new Error((_b = `alias appears to be offline (${alias}): ` + err2.message) !== null && _b !== void 0 ? _b : err2));
                if (isForeignRoom && !connectedToOtherAttendants) {
                    ssb.conn.disconnect(roomAddress);
                }
                return;
            }
            if (!haveMembershipHere) {
                ssb.conn.remember(tunnelAddr, {
                    type: 'room-attendant',
                    key: userId,
                    room: roomId,
                    roomAddress,
                    alias,
                    autoconnect: true,
                });
            }
            cb(null, aliasRpc);
        }
        async function consumeAliasUri(input, cb) {
            if (!input) {
                cb(new Error('missing URI input'));
                return;
            }
            if (typeof input !== 'string') {
                cb(new Error('URI input should be a string'));
                return;
            }
            let url;
            try {
                const coolURL = /^(\w+\.\w+\.\w+|\w+\.\w+\/\w+)$/;
                if (input.match(coolURL)) {
                    url = new URL(`https://${input}`);
                }
                else {
                    url = new URL(input);
                }
            }
            catch (err) {
                cb(err);
                return;
            }
            if (url.protocol.startsWith('http')) {
                url.searchParams.set('encoding', 'json');
                const jsonUrl = url.toString();
                try {
                    const { status, data } = await minireq({
                        url: jsonUrl,
                        method: 'GET',
                        accept: 'application/json',
                        timeout: 10e3,
                    }).promise;
                    if (!(status >= 200 && status < 300)) {
                        cb(new Error(`failed (${status}) to get alias from ${jsonUrl}`));
                        return;
                    }
                    if (jsonResponseFailed(data)) {
                        cb(new Error(data.error));
                        return;
                    }
                    consumeAlias(data, cb);
                }
                catch (err) {
                    cb(err);
                    return;
                }
            }
            else if (url.protocol === 'ssb:') {
                if (url.pathname !== 'experimental' && url.host !== 'experimental') {
                    cb(new Error('SSB URI input isnt experimental'));
                    return;
                }
                const action = url.searchParams.get('action');
                if (action !== ALIAS_URI_ACTION) {
                    cb(new Error(`SSB URI input isnt ${ALIAS_URI_ACTION}: ${input}`));
                    return;
                }
                const data = {
                    multiserverAddress: url.searchParams.get('multiserverAddress'),
                    roomId: url.searchParams.get('roomId'),
                    userId: url.searchParams.get('userId'),
                    alias: url.searchParams.get('alias'),
                    signature: url.searchParams.get('signature'),
                };
                consumeAlias(data, cb);
            }
            else {
                cb(new Error(`unsupported URI input: ${input}`));
                return;
            }
        }
        async function registerAlias(roomKey, alias, cb) {
            var _a;
            if (!Ref.isFeed(roomKey)) {
                cb(new Error(`cannot registerAlias at invalid room ${roomKey}`));
                return;
            }
            const rooms = ssb.tunnel.getRoomsMap();
            let roomRPC = null;
            if (rooms.has(roomKey)) {
                roomRPC = rooms.get(roomKey).rpc;
            }
            if (!roomRPC) {
                const msaddr = ssb.conn.db().getAddressForId(roomKey);
                if (msaddr) {
                    const [err, rpc] = await run(ssb.conn.connect)(msaddr);
                    if (err) {
                        cb(new Error((_a = `cannot registerAlias because ` +
                            `cant reach the room ${roomKey} due to: ` +
                            err.message) !== null && _a !== void 0 ? _a : err));
                        return;
                    }
                    roomRPC = rpc;
                }
            }
            if (!roomRPC) {
                cb(new Error(`cannot registerAlias at offline or unknown room ${roomKey}`));
                return;
            }
            const body = aliasRegistrationStr(roomKey, ssb.id, alias);
            const sig = ssbKeys.sign(config.keys, body);
            roomRPC.room.registerAlias(alias, sig, cb);
        }
        async function revokeAlias(roomKey, alias, cb) {
            var _a;
            if (!Ref.isFeed(roomKey)) {
                cb(new Error(`cannot revokeAlias at invalid room ${roomKey}`));
                return;
            }
            const rooms = ssb.tunnel.getRoomsMap();
            let roomRPC = null;
            if (rooms.has(roomKey)) {
                roomRPC = rooms.get(roomKey).rpc;
            }
            if (!roomRPC) {
                const msaddr = ssb.conn.db().getAddressForId(roomKey);
                if (msaddr) {
                    const [err, rpc] = await run(ssb.conn.connect)(msaddr);
                    if (err) {
                        cb(new Error((_a = `cannot revokeAlias because ` +
                            `cant reach the room ${roomKey} due to: ` +
                            err.message) !== null && _a !== void 0 ? _a : err));
                        return;
                    }
                    roomRPC = rpc;
                }
            }
            if (!roomRPC) {
                cb(new Error(`cannot revokeAlias at offline or unknown room ${roomKey}`));
                return;
            }
            roomRPC.room.revokeAlias(alias, cb);
        }
        return {
            consumeAliasUri,
            registerAlias,
            revokeAlias,
        };
    },
};
