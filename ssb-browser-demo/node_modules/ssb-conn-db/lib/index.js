"use strict";
const fs = require("fs");
const path = require("path");
const os = require("os");
const migration_1 = require("./migration");
const atomic_file_codecs_1 = require("./atomic-file-codecs");
const atomic = require('atomic-file-rw');
const Notify = require('pull-notify');
const msAddress = require('multiserver-address');
const debug = require('debug')('ssb:conn-db');
const defaultOpts = {
    path: path.join(os.homedir(), '.ssb'),
    writeTimeout: 2000,
};
class ConnDB {
    constructor(opts) {
        var _a;
        const dirPath = (_a = opts.path) !== null && _a !== void 0 ? _a : defaultOpts.path;
        const legacyPath = path.join(dirPath, 'gossip.json');
        this._modernPath = path.join(dirPath, 'conn.json');
        this._map = new Map();
        this._notify = Notify();
        this._writeTimeout =
            typeof opts.writeTimeout === 'number'
                ? opts.writeTimeout
                : defaultOpts.writeTimeout;
        this._scheduledWriteTask = null;
        this._closed = false;
        this._loadedPromise = new Promise((resolve, reject) => {
            this._loadedResolve = resolve;
            this._loadedReject = reject;
        });
        this._init(this._modernPath, legacyPath);
    }
    _fileExists(path, cb) {
        if (typeof localStorage === 'undefined' || localStorage === null) {
            cb(fs.existsSync(path));
        }
        else {
            atomic.readFile(path, (err) => {
                if (err)
                    cb(false);
                else
                    cb(true);
            });
        }
    }
    _init(modernPath, legacyPath) {
        this._fileExists(modernPath, (modernExists) => {
            this._fileExists(legacyPath, (legacyExists) => {
                if (!modernExists && !legacyExists) {
                    atomic.writeFile(modernPath, '{}', 'utf8', () => { });
                    this._loadedResolve(true);
                    debug('Created new conn.json because there was no existing ' +
                        'conn.json nor gossip.json');
                    return;
                }
                if (!modernExists && legacyExists) {
                    atomic.readFile(legacyPath, 'utf8', (err, data) => {
                        if (err) {
                            this._loadedReject(err);
                            debug('Failed to load gossip.json, for creating conn.json');
                            return;
                        }
                        const oldVals = JSON.parse(data.toString());
                        const newVals = migration_1.migrateMany(oldVals);
                        const json = atomic_file_codecs_1.selfHealingJSONCodec.encode(newVals);
                        atomic.writeFile(modernPath, json, 'utf8', (err2) => {
                            if (err2) {
                                this._loadedReject(err2);
                                debug('Failed to create conn.json from an existing gossip.json');
                                return;
                            }
                            debug('Migrated gossip.json into conn.json');
                            this._load(newVals);
                        });
                    });
                    return;
                }
                if (modernExists) {
                    atomic.readFile(modernPath, 'utf8', (err, data) => {
                        if (err) {
                            this._loadedReject(err);
                            debug('Failed to load conn.json');
                            return;
                        }
                        const vals = atomic_file_codecs_1.selfHealingJSONCodec.decode(data);
                        this._load(vals);
                    });
                }
            });
        });
    }
    _load(vals) {
        for (const [addr, data] of Object.entries(vals)) {
            this._map.set(addr, data);
        }
        this._loadedResolve(true);
        debug('Loaded conn.json into ConnDB in memory');
    }
    _serialize() {
        const record = {};
        for (let [address, data] of this._map.entries()) {
            record[address] = data;
        }
        return record;
    }
    _write(cb) {
        if (!this._map)
            return;
        debug('Begun serializing and writing ConnDB into conn.json');
        const record = this._serialize();
        const json = atomic_file_codecs_1.selfHealingJSONCodec.encode(record);
        atomic.writeFile(this._modernPath, json, 'utf8', (err) => {
            if (!err)
                debug('Done serializing and writing ConnDB into conn.json');
            if (cb)
                cb(err);
        });
    }
    _cancelScheduleWrite() {
        if (this._scheduledWriteTask) {
            clearTimeout(this._scheduledWriteTask);
        }
    }
    _scheduleWrite() {
        this._cancelScheduleWrite();
        this._scheduledWriteTask = setTimeout(() => {
            this._write((_err) => {
                this._scheduledWriteTask = null;
            });
        }, this._writeTimeout);
    }
    _assertNotClosed() {
        if (this._closed) {
            throw new Error('This ConnDB instance is closed, create a new one.');
        }
    }
    _assertValidAddress(address) {
        if (!msAddress.check(address)) {
            throw new Error('The given address is not a valid multiserver-address');
        }
    }
    _assertValidData(data) {
        if (!data || typeof data !== 'object') {
            throw new Error('The given connection data should have been an object');
        }
    }
    replace(address, data) {
        this._assertNotClosed();
        this._assertValidAddress(address);
        this._assertValidData(data);
        const existed = this._map.has(address);
        if (existed) {
            const { birth } = this._map.get(address);
            this._map.set(address, { birth: birth !== null && birth !== void 0 ? birth : Date.now(), ...data });
            this._notify({ type: 'update', address });
        }
        else {
            this._map.set(address, { birth: Date.now(), ...data });
            this._notify({ type: 'insert', address });
        }
        this._scheduleWrite();
        return this;
    }
    set(address, data) {
        var _a;
        this._assertNotClosed();
        this._assertValidAddress(address);
        this._assertValidData(data);
        const existed = this._map.has(address);
        if (existed) {
            const previous = this._map.get(address);
            this._map.set(address, {
                birth: (_a = previous.birth) !== null && _a !== void 0 ? _a : Date.now(),
                ...previous,
                ...data,
            });
            this._notify({ type: 'update', address });
        }
        else {
            this._map.set(address, { birth: Date.now(), ...data });
            this._notify({ type: 'insert', address });
        }
        this._scheduleWrite();
        return this;
    }
    update(address, x) {
        var _a;
        this._assertNotClosed();
        this._assertValidAddress(address);
        if (!x || (typeof x !== 'object' && typeof x !== 'function')) {
            throw new Error('update() expects an object or a function');
        }
        const existed = this._map.has(address);
        if (!existed)
            return this;
        const previous = this._map.get(address);
        const next = typeof x === 'function' ? x(previous) : x;
        this._map.set(address, {
            birth: (_a = previous.birth) !== null && _a !== void 0 ? _a : Date.now(),
            ...previous,
            ...next,
        });
        this._notify({ type: 'update', address });
        this._scheduleWrite();
        return this;
    }
    get(address) {
        this._assertNotClosed();
        return this._map.get(address);
    }
    getAddressForId(id) {
        this._assertNotClosed();
        for (let [address, data] of this._map.entries()) {
            if (data.key === id)
                return address;
        }
        return undefined;
    }
    has(address) {
        this._assertNotClosed();
        return this._map.has(address);
    }
    delete(address) {
        this._assertNotClosed();
        const hasDeleted = this._map.delete(address);
        if (hasDeleted) {
            this._notify({ type: 'delete', address });
            this._scheduleWrite();
        }
        return hasDeleted;
    }
    entries() {
        this._assertNotClosed();
        return this._map.entries();
    }
    listen() {
        this._assertNotClosed();
        return this._notify.listen();
    }
    loaded() {
        this._assertNotClosed();
        return this._loadedPromise;
    }
    close() {
        var _a;
        this._closed = true;
        this._cancelScheduleWrite();
        this._write();
        (_a = this._map) === null || _a === void 0 ? void 0 : _a.clear();
        this._map = void 0;
        this._notify = void 0;
        this._stateFile = void 0;
        debug('Closed the ConnDB instance');
    }
}
module.exports = ConnDB;
