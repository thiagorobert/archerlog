"use strict";
var u = require("../util");
var Shs = require('multiserver/plugins/shs');
function toBuffer(base64) {
    if (Buffer.isBuffer(base64))
        return base64;
    var i = base64.indexOf('.');
    return Buffer.from(~i ? base64.substring(0, i) : base64, 'base64');
}
function toSodiumKeys(keys) {
    if (typeof keys.public !== 'string' || typeof keys.private !== 'string') {
        return keys;
    }
    return {
        publicKey: toBuffer(keys.public),
        secretKey: toBuffer(keys.private)
    };
}
module.exports = {
    name: 'multiserver-shs',
    version: '1.0.0',
    init: function (api, config) {
        var _a, _b, _c;
        var timeoutHandshake;
        if (!isNaN((_a = config.timers) === null || _a === void 0 ? void 0 : _a.handshake)) {
            timeoutHandshake = (_b = config.timers) === null || _b === void 0 ? void 0 : _b.handshake;
        }
        if (!timeoutHandshake) {
            timeoutHandshake = (config.timers ? 15e3 : 5e3);
        }
        if (config.timeout) {
            timeoutHandshake = config.timeout;
        }
        var shsCap = (_c = (config.caps && config.caps.shs)) !== null && _c !== void 0 ? _c : config.appKey;
        if (!shsCap) {
            throw new Error('secret-stack/plugins/shs must have caps.shs configured');
        }
        var shs = Shs({
            keys: config.keys && toSodiumKeys(config.keys),
            seed: config.seed,
            appKey: toBuffer(shsCap),
            timeout: timeoutHandshake,
            authenticate: function (pub, cb) {
                var id = '@' + u.toId(pub);
                api.auth(id, function (err, auth) {
                    if (err)
                        cb(err);
                    else
                        cb(null, auth || true);
                });
            }
        });
        var id = '@' + u.toId(shs.publicKey);
        api.id = id;
        api.publicKey = id;
        api.multiserver.transform({
            name: 'shs',
            create: function () { return shs; }
        });
    }
};
