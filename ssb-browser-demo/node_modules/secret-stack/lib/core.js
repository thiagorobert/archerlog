"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var u = require("./util");
var Muxrpc = require('muxrpc');
var pull = require('pull-stream');
var MultiServer = require('multiserver');
var Inactive = require('pull-inactivity');
var debug = require('debug')('secret-stack');
function isPlainObject(o) {
    return o && typeof o === 'object' && !Array.isArray(o);
}
function toBase64(s) {
    if (typeof s === 'string')
        return s;
    else
        return s.toString('base64');
}
function each(objOrArr, iter) {
    if (Array.isArray(objOrArr)) {
        objOrArr.forEach(iter);
    }
    else {
        for (var key in objOrArr)
            iter(objOrArr[key], key, objOrArr);
    }
}
function assertHasNameAndCreate(obj, type) {
    if (!isPlainObject(obj) ||
        typeof obj.name !== 'string' ||
        typeof obj.create !== 'function') {
        throw new Error(type + ' must be {name: string, create: function}');
    }
}
function coearseAddress(address) {
    if (isPlainObject(address)) {
        var protocol = 'net';
        if (typeof address.host === 'string' && address.host.endsWith('.onion')) {
            protocol = 'onion';
        }
        return ([protocol, address.host, address.port].join(':') +
            '~' +
            ['shs', toBase64(address.key)].join(':'));
    }
    return address;
}
function isPermsList(list) {
    if (list === null)
        return true;
    if (typeof list === 'undefined')
        return true;
    return Array.isArray(list) && list.every(function (x) { return typeof x === 'string'; });
}
function isPermissions(perms) {
    return (perms &&
        isPlainObject(perms) &&
        isPermsList(perms.allow) &&
        isPermsList(perms.deny));
}
module.exports = {
    manifest: {
        auth: 'async',
        address: 'sync',
        manifest: 'sync',
        multiserver: {
            parse: 'sync',
            address: 'sync'
        }
    },
    permissions: {
        anonymous: {
            allow: ['manifest']
        }
    },
    init: function (api, opts, permissions, manifest) {
        var _a, _b;
        var timeoutInactivity;
        if (!isNaN((_a = opts.timers) === null || _a === void 0 ? void 0 : _a.inactivity)) {
            timeoutInactivity = (_b = opts.timers) === null || _b === void 0 ? void 0 : _b.inactivity;
        }
        timeoutInactivity = timeoutInactivity || (opts.timers ? 600e3 : 5e3);
        if (!opts.connections) {
            var netIn = __assign(__assign({ scope: ['device', 'local', 'public'], transform: 'shs' }, (opts.host ? { host: opts.host } : null)), (opts.port ? { port: opts.port } : null));
            var netOut = {
                transform: 'shs'
            };
            opts.connections = {
                incoming: {
                    net: [netIn]
                },
                outgoing: {
                    net: [netOut]
                }
            };
        }
        var peers = (api.peers = {});
        var transports = [];
        var transforms = [];
        var server;
        var ms;
        var msClient;
        function setupMultiserver() {
            if (api.closed)
                return;
            if (server)
                return server;
            if (transforms.length < 1) {
                throw new Error('secret-stack needs at least 1 transform protocol');
            }
            var serverSuites = [];
            var clientSuites = [];
            var _loop_1 = function (incTransport) {
                opts.connections.incoming[incTransport].forEach(function (inc) {
                    transforms.forEach(function (transform) {
                        transports.forEach(function (transport) {
                            if (transport.name === incTransport &&
                                transform.name === inc.transform) {
                                var msPlugin = transport.create(inc);
                                var msTransformPlugin = transform.create();
                                if (msPlugin.scope() !== inc.scope) {
                                    throw new Error('transport:' +
                                        transport.name +
                                        ' did not remember scope, expected:' +
                                        inc.scope +
                                        ' got:' +
                                        msPlugin.scope());
                                }
                                debug('creating server %s %s host=%s port=%d scope=%s', incTransport, transform.name, inc.host, inc.port, inc.scope || 'undefined');
                                serverSuites.push([msPlugin, msTransformPlugin]);
                            }
                        });
                    });
                });
            };
            for (var incTransport in opts.connections.incoming) {
                _loop_1(incTransport);
            }
            var _loop_2 = function (outTransport) {
                opts.connections.outgoing[outTransport].forEach(function (out) {
                    transforms.forEach(function (transform) {
                        transports.forEach(function (transport) {
                            if (transport.name === outTransport &&
                                transform.name === out.transform) {
                                var msPlugin = transport.create(out);
                                var msTransformPlugin = transform.create();
                                clientSuites.push([msPlugin, msTransformPlugin]);
                            }
                        });
                    });
                });
            };
            for (var outTransport in opts.connections.outgoing) {
                _loop_2(outTransport);
            }
            msClient = MultiServer(clientSuites);
            ms = MultiServer(serverSuites);
            server = ms.server(setupRPC, null, function () {
                api.emit('multiserver:listening');
            });
            if (!server)
                throw new Error('expected server');
            return server;
        }
        setImmediate(setupMultiserver);
        function setupRPC(stream, manf, isClient) {
            var _id = '@' + u.toId(stream.remote);
            var rpc = Muxrpc(manifest, manf !== null && manf !== void 0 ? manf : manifest, api, _id, isClient
                ? permissions.anonymous
                : isPermissions(stream.auth)
                    ? stream.auth
                    : permissions.anonymous, false);
            rpc.id = _id;
            var rpcStream = rpc.stream;
            if (timeoutInactivity > 0 && api.id !== rpc.id) {
                rpcStream = Inactive(rpcStream, timeoutInactivity);
            }
            rpc.meta = stream.meta;
            rpc.stream.address = stream.address;
            pull(stream, rpcStream, stream);
            if (!peers[rpc.id])
                peers[rpc.id] = [];
            peers[rpc.id].push(rpc);
            rpc.once('closed', function () {
                peers[rpc.id].splice(peers[rpc.id].indexOf(rpc), 1);
            });
            api.emit('rpc:connect', rpc, !!isClient);
            return rpc;
        }
        return {
            config: opts,
            auth: function (_pub, cb) {
                cb();
            },
            address: function (scope) {
                return api.getAddress(scope);
            },
            getAddress: function (scope) {
                setupMultiserver();
                return ms.stringify(scope) || null;
            },
            manifest: function () {
                return manifest;
            },
            getManifest: function () {
                return this.manifest();
            },
            connect: function (address, cb) {
                setupMultiserver();
                msClient.client(coearseAddress(address), function (err, stream) {
                    if (err)
                        cb(err);
                    else
                        cb(null, setupRPC(stream, null, true));
                });
            },
            multiserver: {
                transport: function (transport) {
                    if (server) {
                        throw new Error('cannot add protocol after server initialized');
                    }
                    assertHasNameAndCreate(transport, 'transport');
                    debug('Adding transport %s', transport.name);
                    transports.push(transport);
                    return this;
                },
                transform: function (transform) {
                    assertHasNameAndCreate(transform, 'transform');
                    debug('Adding transform %s', transform.name);
                    transforms.push(transform);
                    return this;
                },
                parse: function (str) {
                    return ms.parse(str);
                },
                address: function (scope) {
                    setupMultiserver();
                    return ms.stringify(scope) || null;
                }
            },
            close: function (err, cb) {
                var _a;
                if (typeof err === 'function') {
                    cb = err;
                    err = null;
                }
                api.closed = true;
                if (!server)
                    cb && cb();
                else {
                    ((_a = server.close) !== null && _a !== void 0 ? _a : server)(function (err) {
                        api.emit('close', err);
                        cb && cb(err);
                    });
                }
                if (err) {
                    each(peers, function (connections) {
                        each(connections, function (rpc) {
                            rpc.close(err);
                        });
                    });
                }
            }
        };
    }
};
