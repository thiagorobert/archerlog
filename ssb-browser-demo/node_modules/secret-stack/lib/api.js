"use strict";
var u = require("./util");
var EventEmitter = require('events');
var Hookable = require('hoox');
var identity = function (x) { return x; };
function merge(a, b, mapper) {
    mapper = mapper !== null && mapper !== void 0 ? mapper : identity;
    for (var k in b) {
        if (b[k] &&
            typeof b[k] === 'object' &&
            !Buffer.isBuffer(b[k]) &&
            !Array.isArray(b[k])) {
            a[k] = {};
            merge(a[k], b[k], mapper);
        }
        else {
            a[k] = mapper(b[k], k);
        }
    }
    return a;
}
module.exports = function Api(plugins, defaultConfig) {
    function create(inputOpts) {
        var opts = merge(merge({}, defaultConfig), inputOpts);
        var api = new EventEmitter();
        create.plugins.forEach(function (plug) {
            var _api = plug.init.call({}, api, opts, create.permissions, create.manifest);
            if (plug.name) {
                var camelCaseName = u.toCamelCase(plug.name);
                var o = {};
                o[camelCaseName] = _api;
                _api = o;
            }
            api = merge(api, _api, function (val, key) {
                if (typeof val === 'function') {
                    val = Hookable(val);
                    if (plug.manifest && plug.manifest[key] === 'sync') {
                        u.hookOptionalCB(val);
                    }
                }
                return val;
            });
        });
        return api;
    }
    create.plugins = [];
    create.manifest = {};
    create.permissions = {};
    create.use = function (plug) {
        if (Array.isArray(plug)) {
            plug.forEach(create.use);
            return create;
        }
        if (!plug.init) {
            if (typeof plug === 'function') {
                create.plugins.push({ init: plug });
                return create;
            }
            else {
                throw new Error('plugins *must* have "init" method');
            }
        }
        if (plug.name && typeof plug.name === 'string') {
            var found = create.plugins.some(function (p) { return p.name === plug.name; });
            if (found) {
                console.error('plugin named:' + plug.name + ' is already loaded, skipping');
                return create;
            }
        }
        var name = plug.name;
        if (plug.manifest) {
            create.manifest = u.merge.manifest(create.manifest, plug.manifest, u.toCamelCase(name));
        }
        if (plug.permissions) {
            create.permissions = u.merge.permissions(create.permissions, plug.permissions, u.toCamelCase(name));
        }
        create.plugins.push(plug);
        return create;
    };
    [].concat(plugins).filter(Boolean).forEach(create.use);
    return create;
};
