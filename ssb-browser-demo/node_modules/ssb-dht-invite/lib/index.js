"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const run = require("promisify-tuple");
const secret_stack_decorators_1 = require("secret-stack-decorators");
const crypto = require('crypto');
const pull = require('pull-stream');
const Pushable = require('pull-pushable');
const Notify = require('pull-notify');
const DHT = require('multiserver-dht');
const explain = require('explain-error');
const level = require('level');
const path = require('path');
const debug = require('debug')('ssb:dht-invite');
function dhtPeerConnected(type, addr, key, det) {
    if (type !== 'connected')
        return false;
    if (!addr.startsWith('dht:'))
        return false;
    if (!key)
        return false;
    if (!(det === null || det === void 0 ? void 0 : det.rpc))
        return false;
    if (det.rpc.meta !== 'dht')
        return false;
    return true;
}
/**
 * Checks if a remote DHT peer is the client, while we are the host
 */
function dhtClientConnected({ type, address, key, details }) {
    if (!dhtPeerConnected(type, address, key, details))
        return false;
    return !details.isClient;
}
/**
 * Checks if a remote DHT peer is the host, while we are the client
 */
function dhtServerConnected({ type, address, key, details }) {
    if (!dhtPeerConnected(type, address, key, details))
        return false;
    return details.isClient;
}
function dhtPeerDisconnected({ type, address, key }) {
    if (type !== 'disconnected')
        return false;
    if (!address.startsWith('dht:'))
        return false;
    if (!key)
        return false;
    return true;
}
let dhtInvite = class dhtInvite {
    constructor(ssb, config) {
        this.start = (cb) => {
            if (this.initialized)
                return cb(null, true);
            debug('start()');
            this.setupServerCodesDB();
            this.initialized = true;
            cb(null, true);
        };
        this.create = async (cb) => {
            if (!this.initialized || !this.serverCodesDB) {
                return cb(new Error('Cannot call dhtInvite.create() before dhtInvite.start()'));
            }
            const seed = crypto.randomBytes(32).toString('base64');
            const claimer = 'unclaimed';
            const [err] = await run(this.serverCodesDB.put)(seed, claimer);
            if (err)
                return cb(err);
            this.serverCodesCache.set(seed, { claimer, online: false });
            this.emitServerChannels(this.serverCodesCache);
            this.emitServerCodesHosting();
            cb(null, 'dht:' + seed + ':' + this.ssb.id);
        };
        this.use = async (req, cb) => {
            if (!this.initialized || !this.serverCodesDB) {
                return cb(new Error('Cannot call dhtInvite.use() before dhtInvite.start()'));
            }
            const seed = req.seed;
            const friendId = req.feed;
            debug('use() called with request %o', req);
            // fetch claimer
            const [err, claimer] = await run(this.serverCodesDB.get)(seed);
            if (err)
                return cb(explain(err, 'Cannot `use` an invite that does not exist'));
            if (claimer === friendId) {
                debug('use() is redundant, has already happened');
                return cb(null, { seed: seed, feed: this.ssb.id });
            }
            else if (claimer !== 'unclaimed') {
                return cb(new Error('Cannot `use` an already claimed invite'));
            }
            // claimer is definitely "unclaimed"
            debug('use() will claim invite');
            const [err2] = await run(this.serverCodesDB.put)(seed, friendId);
            if (err2)
                return cb(err2);
            this.serverCodesCache.set(seed, { claimer: friendId, online: true });
            this.emitServerCodesHosting();
            // follow the remote peer if we got ssb-friends and they're not yet followed
            if (this.ssb.friends) {
                const [err3, alreadyFollow] = await run(this.ssb.friends.isFollowing)({ source: this.ssb.id, dest: friendId });
                if (err3)
                    return cb(err3);
                if (alreadyFollow) {
                    debug('use() will not follow remote peer because they are already followed');
                }
                else {
                    debug('use() will follow remote peer');
                    const [err4] = await run(this.ssb.publish)({
                        type: 'contact',
                        contact: friendId,
                        following: true,
                    });
                    if (err4)
                        return cb(err4);
                }
            }
            else {
                debug('no ssb-friends plugin found, so we wont follow the remote peer');
                console.error('ssb-dht-invite requires ssb-friends when following remote peers');
            }
            const res = { seed: seed, feed: this.ssb.id };
            debug('use() will respond with %o', res);
            cb(null, res);
        };
        this.accept = async (invite, cb) => {
            // parse invite code
            const [e1, parsed] = this.parseInvite(invite);
            if (e1)
                return cb(e1);
            const { remoteId, addr, seed } = parsed;
            // follow the remote peer if we got ssb-friends and they're not yet followed
            if (this.ssb.friends) {
                const [err3, alreadyFollow] = await run(this.ssb.friends.isFollowing)({ source: this.ssb.id, dest: remoteId });
                if (err3)
                    return cb(err3);
                if (alreadyFollow) {
                    debug('accept() wont follow remote peer because they are already followed');
                }
                else {
                    debug('accept() will follow friend %s', remoteId);
                    const [e2] = await run(this.ssb.publish)({
                        type: 'contact',
                        contact: remoteId,
                        following: true,
                    });
                    if (e2)
                        return cb(explain(e2, 'Unable to follow friend behind invite'));
                }
            }
            else {
                debug('no ssb-friends plugin found, so we wont follow the remote peer');
                console.error('ssb-dht-invite requires ssb-friends when following remote peers');
            }
            debug('accept() will remember the address %s in ConnDB', addr);
            this.ssb.conn.remember(addr, { type: 'dht' });
            debug('accept() will ssb.conn.connect to remote peer %s', addr);
            const [e3, rpc] = await run(this.ssb.conn.connect)(addr, { type: 'dht' });
            if (e3)
                return cb(explain(e3, 'Could not connect to DHT server'));
            debug('accept() has ssb.conn.connected to remote peer %s', addr);
            cb(null, true);
        };
        this.remove = async (invite, cb) => {
            if (!this.initialized || !this.serverCodesDB) {
                return cb(new Error('Cannot call dhtInvite.remove() before dhtInvite.start()'));
            }
            if (this.serverCodesCache.has(invite)) {
                const [err] = await run(this.serverCodesDB.del)(invite);
                if (err)
                    return cb(explain(err, 'Could not delete server invite code'));
                this.serverCodesCache.delete(invite);
                this.emitServerChannels(this.serverCodesCache);
                this.emitServerCodesHosting();
            }
            cb(null, true);
        };
        this.hostingInvites = () => this.serverCodesHosting.listen();
        this.ssb = ssb;
        this.config = config;
        this.serverChannels = Pushable();
        this.serverCodesCache = new Map();
        this.serverCodesHosting = Notify();
        this.onlineRemoteClients = new Set();
        this.initialized = false;
        this.serverCodesDB = null;
        this.init();
    }
    init() {
        var _a, _b, _c;
        if (!((_a = this.ssb.conn) === null || _a === void 0 ? void 0 : _a.connect) || !((_b = this.ssb.conn) === null || _b === void 0 ? void 0 : _b.hub)) {
            throw new Error('plugin ssb-dht-invite requires ssb-conn to be installed');
        }
        if (!((_c = this.ssb.friends) === null || _c === void 0 ? void 0 : _c.isFollowing)) {
            debug('this plugin works better with ssb-friends installed, ' +
                'but it was not found');
        }
        // Install the multiserver plugin for DHT
        this.ssb.multiserver.transport({
            name: 'dht',
            create: (dhtConfig) => DHT({ keys: this.serverChannels, port: dhtConfig.port }),
        });
        // Update record of online RPC clients using DHT transport.
        pull(this.ssb.conn.hub().listen(), pull.filter(dhtClientConnected), pull.drain(({ key }) => {
            this.onlineRemoteClients.add(key);
            if (this.initialized) {
                this.updateServerCodesCacheOnlineStatus();
                this.emitServerCodesHosting();
            }
        }));
        pull(this.ssb.conn.hub().listen(), pull.filter(dhtPeerDisconnected), pull.drain(({ key }) => {
            if (!this.onlineRemoteClients.has(key))
                return;
            this.onlineRemoteClients.delete(key);
            if (this.initialized) {
                this.updateServerCodesCacheOnlineStatus();
                this.emitServerCodesHosting();
            }
        }));
        // Finish the accept() steps by calling the remote peer's use()
        pull(this.ssb.conn.hub().listen(), pull.filter(dhtServerConnected), pull.drain(({ details, address }) => {
            const seed = this.addressToSeed(address);
            const req = { seed, feed: this.ssb.id };
            debug('connected to DHT host, will call its use(%o)', req);
            details.rpc.dhtInvite.use(req, (err) => {
                console.error('Could not claim invite code at DHT host because:', err);
            });
        }));
    }
    /**
     * Update the online status of the server codes cache.
     */
    updateServerCodesCacheOnlineStatus() {
        this.serverCodesCache.forEach((hInfo, seed) => {
            const claimer = hInfo.claimer;
            if (claimer === 'unclaimed')
                return;
            const online = this.onlineRemoteClients.has(claimer);
            if (hInfo.online !== online) {
                this.serverCodesCache.set(seed, { claimer, online });
            }
        });
    }
    /**
     * Emit an Array<{seed, claimer, online}> on the hostingInvites
     * notifier stream.
     */
    emitServerCodesHosting() {
        this.serverCodesHosting(Array.from(this.serverCodesCache.entries()).map(([seed, { claimer, online }]) => ({ seed, claimer, online })));
    }
    emitServerChannels(map) {
        this.serverChannels.push(Array.from(map.entries()).map(([seed]) => seed + ':' + this.ssb.id));
    }
    async setupServerCodesDB() {
        const dbPath = path.join(this.config.path, 'dhtServerCodes');
        const opts = { valueEncoding: 'json' };
        const [err2, db] = await run(level)(dbPath, opts);
        if (err2)
            throw err2;
        this.serverCodesDB = db;
        this.serverCodesDB.get = this.serverCodesDB.get.bind(this.serverCodesDB);
        this.serverCodesDB.put = this.serverCodesDB.put.bind(this.serverCodesDB);
        this.serverCodesDB.del = this.serverCodesDB.del.bind(this.serverCodesDB);
        this.serverCodesDB.createReadStream().on('data', (data) => {
            const seed = data.key;
            const claimer = data.value;
            debug('server channels: emit %s', seed + ':' + this.ssb.id);
            this.serverCodesCache.set(seed, { claimer, online: false });
            this.emitServerChannels(this.serverCodesCache);
            this.emitServerCodesHosting();
            this.updateServerCodesCacheOnlineStatus();
        });
    }
    /**
     * Given an invite code as a string, return the seed and remoteId.
     */
    parseInvite(invite) {
        if (typeof invite !== 'string' || invite.length === 0) {
            return [new Error('Cannot `accept` the DHT invite, it is missing')];
        }
        const parts = invite.split(':');
        if (parts.length !== 3) {
            return [
                new Error('Cannot `accept` the DHT invite, it is missing some parts'),
            ];
        }
        if (parts[0] !== 'dht') {
            return [
                new Error('Cannot `accept` the DHT invite, it should start with "dht"'),
            ];
        }
        const seed = parts[1];
        if (seed.length === 0) {
            return [
                new Error('Cannot `accept` the DHT invite, the seed part is missing'),
            ];
        }
        const remoteId = parts[2];
        if (remoteId.length === 0) {
            return [
                new Error('Cannot `accept` the DHT invite, the feed id part is missing'),
            ];
        }
        const pubkey = remoteId.replace(/^\@/, '').replace(/\.ed25519$/, '');
        const transform = `shs:${pubkey}`;
        const addr = invite + '~' + transform;
        return [undefined, { seed, addr, remoteId }];
    }
    addressToSeed(address) {
        const parts = address.split(':');
        if (parts.length < 2 || parts[0] !== 'dht' || !parts[1]) {
            throw new Error('Cannot get seed from address: ' + address);
        }
        return parts[1];
    }
};
__decorate([
    secret_stack_decorators_1.muxrpc('async', { master: 'allow' })
], dhtInvite.prototype, "start", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('async', { master: 'allow' })
], dhtInvite.prototype, "create", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('async', { anonymous: 'allow' })
], dhtInvite.prototype, "use", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('async', { master: 'allow' })
], dhtInvite.prototype, "accept", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('async', { master: 'allow' })
], dhtInvite.prototype, "remove", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('source', { master: 'allow' })
], dhtInvite.prototype, "hostingInvites", void 0);
dhtInvite = __decorate([
    secret_stack_decorators_1.plugin('1.0.0')
], dhtInvite);
module.exports = dhtInvite;
