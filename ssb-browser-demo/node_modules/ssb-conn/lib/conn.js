"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CONN = void 0;
const ConnDB = require("ssb-conn-db");
const ConnHub = require("ssb-conn-hub");
const ConnStaging = require("ssb-conn-staging");
const ConnQuery = require("ssb-conn-query");
const secret_stack_decorators_1 = require("secret-stack-decorators");
const interpool_glue_1 = require("./interpool-glue");
const ping = require('pull-ping');
let CONN = class CONN {
    constructor(ssb, cfg) {
        this.remember = (address, data = {}) => {
            this._db.set(address, data);
        };
        this.forget = (address) => {
            this._db.delete(address);
        };
        this.dbPeers = () => [...this._db.entries()];
        this.connect = (address, b, c) => {
            if (c && (typeof b === 'function' || !b)) {
                throw new Error('CONN.connect() received incorrect arguments');
            }
            const last = !!c ? c : b;
            const cb = (typeof last === 'function' ? last : null);
            const data = (typeof b === 'object' ? b : {});
            this._hub.connect(address, data).then(result => cb === null || cb === void 0 ? void 0 : cb(null, result), err => cb === null || cb === void 0 ? void 0 : cb(err));
        };
        this.disconnect = (address, cb) => {
            this._hub.disconnect(address).then(result => cb === null || cb === void 0 ? void 0 : cb(null, result), err => cb === null || cb === void 0 ? void 0 : cb(err));
        };
        this.peers = () => this._hub.liveEntries();
        this.stage = (address, data = { type: 'internet' }) => {
            if (!!this._hub.getState(address))
                return false;
            if (data.key) {
                for (const other of this._hub.entries()) {
                    if (other[1].key === data.key)
                        return false;
                }
            }
            return this._staging.stage(address, data);
        };
        this.unstage = (address) => {
            return this._staging.unstage(address);
        };
        this.stagedPeers = () => this._staging.liveEntries();
        this.start = () => {
            return this.startScheduler();
        };
        this.stop = () => {
            this.stopScheduler();
        };
        this.ping = () => {
            var _a, _b;
            const MIN = 10e3;
            const DEFAULT = 5 * 60e3;
            const MAX = 30 * 60e3;
            let timeout = (_b = (_a = this.config.timers) === null || _a === void 0 ? void 0 : _a.ping) !== null && _b !== void 0 ? _b : DEFAULT;
            timeout = Math.max(MIN, Math.min(timeout, MAX));
            return ping({ timeout });
        };
        this.db = () => this._db;
        this.hub = () => this._hub;
        this.staging = () => this._staging;
        this.query = () => this._query;
        this.ssb = ssb;
        this.config = cfg;
        this._db = new ConnDB({ path: this.config.path, writeTimeout: 1e3 });
        this._hub = new ConnHub(this.ssb);
        this._staging = new ConnStaging();
        this._query = new ConnQuery(this._db, this._hub, this._staging);
        this.initialize();
    }
    initialize() {
        this.setupCloseHook();
        this.maybeAutoStartScheduler();
        interpool_glue_1.interpoolGlue(this._db, this._hub, this._staging);
    }
    setupCloseHook() {
        const that = this;
        this.ssb.close.hook(function (fn, args) {
            that.stopScheduler();
            that._db.close();
            that._hub.close();
            that._staging.close();
            return fn.apply(this, args);
        });
    }
    maybeAutoStartScheduler() {
        var _a;
        if (((_a = this.config.conn) === null || _a === void 0 ? void 0 : _a.autostart) === false) {
        }
        else {
            this.startScheduler();
        }
    }
    async startScheduler() {
        await this._db.loaded();
        if (this.ssb.connScheduler) {
            this.ssb.connScheduler.start();
        }
        else {
            setTimeout(() => {
                if (this.ssb.connScheduler) {
                    this.ssb.connScheduler.start();
                }
                else {
                    console.error('There is no ConnScheduler! ' +
                        'The CONN plugin will remain in manual mode.');
                }
            }, 100);
        }
    }
    stopScheduler() {
        if (this.ssb.connScheduler)
            this.ssb.connScheduler.stop();
    }
};
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], CONN.prototype, "remember", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], CONN.prototype, "forget", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], CONN.prototype, "dbPeers", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('async')
], CONN.prototype, "connect", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('async')
], CONN.prototype, "disconnect", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('source')
], CONN.prototype, "peers", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], CONN.prototype, "stage", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], CONN.prototype, "unstage", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('source')
], CONN.prototype, "stagedPeers", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], CONN.prototype, "start", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], CONN.prototype, "stop", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('duplex', { anonymous: 'allow' })
], CONN.prototype, "ping", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], CONN.prototype, "db", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], CONN.prototype, "hub", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], CONN.prototype, "staging", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], CONN.prototype, "query", void 0);
CONN = __decorate([
    secret_stack_decorators_1.plugin('1.0.0')
], CONN);
exports.CONN = CONN;
