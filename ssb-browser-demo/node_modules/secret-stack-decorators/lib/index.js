"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function muxrpc(type, perms) {
    return function DecorateManifestMethod(target, methodName) {
        var statics = target.constructor;
        if (target[methodName] && typeof target[methodName] !== 'function') {
            throw new Error('You can only use the @muxrpc decorator on methods, ' +
                'are you sure that is the case for `' +
                methodName +
                '`?');
        }
        // Augment the 'manifest' static field
        if (!statics.manifest) {
            statics.manifest = {};
        }
        statics.manifest[methodName] = type;
        // Augment the 'permissions' static field
        if (perms) {
            if (!statics.permissions) {
                statics.permissions = {};
            }
            for (var _i = 0, _a = Object.keys(perms); _i < _a.length; _i++) {
                var role = _a[_i];
                var decision = perms[role];
                if (!statics.permissions[role]) {
                    statics.permissions[role] = {};
                }
                if (!statics.permissions[role][decision]) {
                    statics.permissions[role][decision] = [];
                }
                statics.permissions[role][decision].push(methodName);
            }
        }
    };
}
exports.muxrpc = muxrpc;
function plugin(version) {
    return function DecorateSecretStackPlugin(constructor) {
        if (!version || typeof version !== 'string') {
            throw new Error('The @plugin decorator expects one argument: a `version` string');
        }
        // Set the 'version' static field
        constructor.version = version;
        // Set the 'init' static field
        constructor.init = function init() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var api = new (constructor.bind.apply(constructor, [void 0].concat(args)))();
            // Hide all other properties and methods, except
            // those declared in the manifest
            for (var property in api) {
                if (property in constructor.manifest) {
                    var propertyValue = api[property];
                    if (typeof propertyValue === 'function' && !Object.getOwnPropertyDescriptors(api)[property]) {
                        // not a this-bound method, bind it
                        propertyValue = propertyValue.bind(api);
                    }
                    Object.defineProperty(api, property, {
                        enumerable: true,
                        configurable: false,
                        writable: true,
                        value: propertyValue,
                    });
                }
                else {
                    Object.defineProperty(api, property, {
                        enumerable: false,
                        configurable: false,
                        writable: true,
                        value: api[property],
                    });
                }
            }
            for (var property in constructor.manifest) {
                Object.defineProperty(api, property, {
                    enumerable: true,
                    configurable: false,
                    writable: true,
                    value: api[property],
                });
            }
            return api;
        };
    };
}
exports.plugin = plugin;
//# sourceMappingURL=index.js.map