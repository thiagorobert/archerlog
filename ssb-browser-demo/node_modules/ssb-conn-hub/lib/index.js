"use strict";
const run = require("promisify-tuple");
const pull = require('pull-stream');
const cat = require('pull-cat');
const Notify = require('pull-notify');
const IP = require('ip');
const msNetPlugin = require('multiserver/plugins/net')({});
const msAddress = require('multiserver-address');
const Ref = require('ssb-ref');
const debug = require('debug')('ssb:conn-hub');
function noop() { }
function inferPeerType(address, meta) {
    if (address.startsWith('bt:'))
        return 'bt';
    if (address.startsWith('dht:') || meta === 'dht')
        return 'dht';
    if (address.startsWith('tunnel:'))
        return 'tunnel';
    if (address.startsWith('net:')) {
        const netAddr = address.split('~')[0];
        const parsed = msNetPlugin.parse(netAddr);
        if (parsed === null || parsed === void 0 ? void 0 : parsed.host) {
            if (IP.isPrivate(parsed.host))
                return 'lan';
            else
                return 'internet';
        }
    }
    return;
}
class ConnHub {
    constructor(server) {
        this._onRpcConnect = (rpc, isClient) => {
            var _a;
            if (rpc.id === this._server.id)
                return;
            if (this._server.ready && !this._server.ready()) {
                rpc.close(true, noop);
                return;
            }
            const peer = this._getPeerByKey(rpc.id);
            if (!peer && isClient) {
                rpc._connectRetries = (_a = rpc._connectRetries) !== null && _a !== void 0 ? _a : 0;
                if (isClient && rpc._connectRetries < 4) {
                    setTimeout(() => {
                        this._onRpcConnect(rpc, isClient);
                    }, 200);
                    rpc._connectRetries += 1;
                }
                else if (isClient) {
                    debug('our secret-stack initiated an RPC connection with %s but not ' +
                        'through the ssb-conn-hub connect() API', rpc.id);
                }
                return;
            }
            if (!peer) {
                debug('peer %s initiated an RPC connection with us', rpc.id);
            }
            const [address, data] = !peer
                ? [rpc.stream.address, { key: rpc.id }]
                : peer;
            if (!data.type) {
                data.inferredType = inferPeerType(address, rpc.stream.meta);
            }
            const key = data.key;
            const state = 'connected';
            const disconnect = (cb) => rpc.close(true, cb !== null && cb !== void 0 ? cb : noop);
            this._setPeer(address, { ...data, state, disconnect });
            this._rpcs.set(address, rpc);
            debug('connected to %s', address);
            this._notifyEvent({
                type: state,
                address,
                key,
                details: { rpc, isClient },
            });
            this._updateLiveEntries();
            rpc.on('closed', () => {
                this._rpcs.delete(address);
                this._peers.delete(address);
                debug('disconnected from %s', address);
                this._notifyEvent({ type: 'disconnected', address, key });
                this._updateLiveEntries();
            });
        };
        this._server = server;
        this._closed = false;
        this._connectRetries = new Set();
        this._peers = new Map();
        this._rpcs = new Map();
        this._notifyEvent = Notify();
        this._notifyEntries = Notify();
        this._init();
    }
    _init() {
        this._server.addListener('rpc:connect', this._onRpcConnect);
    }
    _assertNotClosed() {
        if (this._closed) {
            throw new Error('This ConnHub instance is closed, create a new one.');
        }
    }
    _assertValidAddress(address) {
        if (!msAddress.check(address)) {
            throw new Error('The given address is not a valid multiserver-address');
        }
    }
    _updateLiveEntries() {
        this._notifyEntries(Array.from(this._peers.entries()));
    }
    _setPeer(address, data) {
        const now = Date.now();
        const hubUpdated = now;
        const previousData = this._peers.get(address);
        if (previousData) {
            Object.keys(data).forEach((key) => {
                const k = key;
                if (typeof data[k] === 'undefined')
                    delete data[k];
            });
            this._peers.set(address, { ...previousData, hubUpdated, ...data });
        }
        else if (!data.state) {
            debug('unexpected control flow, we cannot add a peer without state');
        }
        else {
            const hubBirth = now;
            this._peers.set(address, { ...data, hubBirth, hubUpdated });
        }
    }
    _getPeerByKey(key) {
        for (let [address, data] of this._peers.entries()) {
            if (data.key === key)
                return [address, data];
        }
        return undefined;
    }
    async connect(address, data) {
        this._assertNotClosed();
        this._assertValidAddress(address);
        if (this._peers.has(address)) {
            const peer = this._peers.get(address);
            if (peer.state === 'connected') {
                if (this._rpcs.has(address))
                    return this._rpcs.get(address);
                else
                    return false;
            }
            else if (peer.state === 'connecting') {
                return new Promise((resolve, reject) => {
                    let drainer;
                    setTimeout(() => {
                        if (drainer)
                            drainer.abort();
                        resolve(false);
                    }, 60e3);
                    pull(this._notifyEvent.listen(), pull.filter((ev) => ev.type === 'connected' && ev.address === address), pull.take(1), (drainer = pull.drain((ev) => {
                        resolve(ev.details.rpc);
                    }, (err) => {
                        if (err && err !== true)
                            reject(err);
                    })));
                });
            }
            else if (peer.state === 'disconnecting') {
                this._connectRetries.add(address);
                return false;
            }
            else {
                debug('unexpected control flow, peer %o has bad state', peer);
            }
        }
        const state = 'connecting';
        const key = Ref.getKeyFromAddress(address);
        if (data) {
            this._setPeer(address, { ...data, state, key });
        }
        else {
            this._setPeer(address, { state, key });
        }
        debug('connecting to %s', address);
        this._notifyEvent({ type: state, address, key });
        this._updateLiveEntries();
        const [err, rpc] = await run(this._server.connect)(address);
        if (err) {
            this._peers.delete(address);
            debug('failed to connect to %s because: %s', address, err.message);
            this._notifyEvent({
                type: 'connecting-failed',
                address,
                key,
                details: err,
            });
            this._updateLiveEntries();
            throw err;
        }
        const peer = this._peers.get(address);
        if (!peer || peer.state !== 'connected') {
            const state = 'connected';
            this._setPeer(address, { state, key });
            debug('connected to %s', address);
            this._notifyEvent({
                type: state,
                address,
                key,
                details: { rpc },
            });
            this._updateLiveEntries();
        }
        this._rpcs.set(address, rpc);
        return rpc;
    }
    async disconnect(address) {
        this._assertNotClosed();
        this._assertValidAddress(address);
        if (!this._peers.has(address))
            return false;
        const peer = this._peers.get(address);
        const key = Ref.getKeyFromAddress(address);
        const prevState = peer.state;
        if (prevState !== 'disconnecting') {
            const state = 'disconnecting';
            this._setPeer(address, { state, key });
            debug('disconnecting from %s', address);
            this._notifyEvent({ type: state, address, key });
            this._updateLiveEntries();
        }
        if (peer.disconnect) {
            const [err] = await run(peer.disconnect)();
            if (err) {
                debug('failed to disconnect from %s because: %s', address, err.message);
                this._notifyEvent({
                    type: 'disconnecting-failed',
                    address,
                    key,
                    details: err,
                });
                this._setPeer(address, { state: prevState, key });
                this._updateLiveEntries();
                throw err;
            }
        }
        this._peers.delete(address);
        debug('disconnected from %s', address);
        this._notifyEvent({ type: 'disconnected', address, key });
        this._updateLiveEntries();
        if (this._connectRetries.has(address)) {
            this._connectRetries.delete(address);
            this.connect(address);
        }
        return true;
    }
    update(address, data) {
        this._assertNotClosed();
        this._assertValidAddress(address);
        if (this._peers.has(address)) {
            this._setPeer(address, data);
            this._updateLiveEntries();
            return true;
        }
        else {
            return false;
        }
    }
    reset() {
        this._assertNotClosed();
        for (var id in this._server.peers) {
            if (id !== this._server.id) {
                for (let peer of this._server.peers[id]) {
                    peer.close(true, noop);
                }
            }
        }
    }
    entries() {
        this._assertNotClosed();
        return this._peers.entries();
    }
    liveEntries() {
        this._assertNotClosed();
        return cat([
            pull.values([Array.from(this._peers.entries())]),
            this._notifyEntries.listen(),
        ]);
    }
    getState(address) {
        this._assertNotClosed();
        this._assertValidAddress(address);
        if (!this._peers.has(address))
            return undefined;
        return this._peers.get(address).state;
    }
    listen() {
        this._assertNotClosed();
        return this._notifyEvent.listen();
    }
    close() {
        this._server.removeListener('rpc:connect', this._onRpcConnect);
        this._closed = true;
        this._peers.clear();
        this._rpcs.clear();
        this._notifyEvent.end();
        this._notifyEntries.end();
        debug('closed the ConnHub instance');
    }
}
module.exports = ConnHub;
