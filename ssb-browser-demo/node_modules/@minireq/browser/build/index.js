import { makeQueryString, defaultSerializers, defaults, } from '@minireq/common';
export function makeRequest(serializers = defaultSerializers, defaultOptions = {}) {
    return function request(options) {
        var _a;
        const opts = Object.assign(Object.assign(Object.assign({}, defaults), defaultOptions), options);
        const url = opts.url + makeQueryString(opts.query);
        // Because fuck JavaScript Promises and their garbage error handing regarding throw
        let resolve;
        let reject;
        const request = new XMLHttpRequest();
        const abort = () => {
            request.abort();
        };
        if (opts.timeout)
            request.timeout = opts.timeout;
        if (opts.onTimeout) {
            request.addEventListener('timeout', opts.onTimeout);
        }
        request.addEventListener('load', () => {
            var _a, _b;
            let response = request.response;
            if (opts.responseType === 'parsed') {
                const mimeType = (_a = request
                    .getResponseHeader('Content-Type')) === null || _a === void 0 ? void 0 : _a.split(';')[0];
                if (mimeType && ((_b = serializers[mimeType]) === null || _b === void 0 ? void 0 : _b.parse)) {
                    response = serializers[mimeType].parse(response);
                }
            }
            resolve({
                status: request.status,
                data: response,
            });
        });
        request.addEventListener('error', reject);
        if (opts.progress) {
            request.onprogress = opts.progress;
        }
        if (opts.uploadProgress) {
            request.upload.onprogress = opts.uploadProgress;
        }
        request.open(opts.method, url, true);
        request.responseType =
            opts.responseType === 'binary' ? 'arraybuffer' : 'text';
        if (opts.headers) {
            for (const key in opts.headers) {
                request.setRequestHeader(key, opts.headers[key]);
            }
        }
        if (opts.contentType) {
            request.setRequestHeader('Content-Type', opts.contentType);
        }
        if (opts.accept) {
            request.setRequestHeader('Accept', opts.accept);
        }
        if (opts.auth) {
            request.setRequestHeader('Authorization', `Basic ${btoa(opts.auth.user + ':' + opts.auth.password)}`);
        }
        if (opts.send) {
            if (typeof opts.send === 'string' ||
                opts.send instanceof Blob ||
                opts.send instanceof ArrayBuffer ||
                opts.send instanceof Int8Array ||
                opts.send instanceof Uint8Array ||
                opts.send instanceof Uint8ClampedArray ||
                opts.send instanceof Int16Array ||
                opts.send instanceof Uint16Array ||
                opts.send instanceof Int32Array ||
                opts.send instanceof Uint32Array ||
                opts.send instanceof Float32Array ||
                opts.send instanceof Float64Array ||
                opts.send instanceof DataView ||
                opts.send instanceof FormData ||
                opts.send instanceof URLSearchParams) {
                request.send(opts.send);
            }
            else if ((_a = serializers[opts.contentType]) === null || _a === void 0 ? void 0 : _a.convert) {
                request.send(serializers[opts.contentType].convert(opts.send));
            }
            else {
                throw new Error(`Could not find a serializer for content type ${opts.contentType}`);
            }
        }
        else {
            request.send();
        }
        return {
            promise: new Promise((res, rej) => {
                resolve = res;
                reject = rej;
            }),
            abort,
        };
    };
}
//# sourceMappingURL=index.js.map