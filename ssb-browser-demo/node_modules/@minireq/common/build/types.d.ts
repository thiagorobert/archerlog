export declare type GET = 'GET';
export declare type HEAD = 'HEAD';
export declare type POST = 'POST';
export declare type PUT = 'PUT';
export declare type DELETE = 'DELETE';
export declare type CONNECT = 'CONNECT';
export declare type OPTIONS = 'OPTIONS';
export declare type TRACE = 'OPTIONS';
export declare type PATCH = 'PATCH';
export declare type METHOD = GET | HEAD | POST | PUT | DELETE | CONNECT | OPTIONS | TRACE | PATCH;
export declare type ResponseType = 'raw_text' | 'binary' | 'parsed';
export declare type ResultMapping<T> = {
    binary: ArrayBuffer;
    raw_text: string;
    parsed: T;
};
export declare type RequestFn<T = any> = RequestFunction<T, ResponseType>;
export declare type RequestFunction<T = any, Type extends ResponseType = 'parsed'> = (options: RequestOpts<METHOD, Type>) => Result<ResultMapping<T>[Type]>;
export declare type RequestOptions = RequestOpts<METHOD, ResponseType>;
export declare type Progress = {
    lengthComputable: boolean;
    loaded: number;
    total: number;
};
export declare type RequestOpts<Method, Type extends ResponseType> = {
    method: Method;
    url: string;
    headers?: {
        [name: string]: string;
    };
    /**
     * Either a premade query string or an object of key: value pairs
     */
    query?: string | Record<string, string | number | boolean>;
    /**
     * If this is an object, the contentType will be used to serialize it
     */
    send?: string | Blob | Record<string, any> | BufferSource | FormData | URLSearchParams | ReadableStream;
    accept?: string;
    /**
     * @default 'application/json'
     */
    contentType?: string;
    /**
     * Credentials for HTTP basic auth
     */
    auth?: {
        user: string;
        password: string;
    };
    attach?: {
        [field: string]: Blob | File;
    };
    /**
     * A callback for listening to **download** progress events
     */
    progress?: (x: Progress) => void;
    /**
     * A callback for listening to **upload** progress events
     */
    uploadProgress?: (x: Progress) => void;
    agent?: {
        key: string;
        cert: string;
    };
    /**
     * Usually 'parsed' or 'arraybuffer' for binary data
     * @default 'parsed'
     */
    responseType?: Type;
    /**
     * Timeout in milliseconds
     */
    timeout?: number;
    onTimeout?: (x: Progress) => void;
};
export declare type Response<T> = {
    data: T;
    status: number;
};
export declare type Result<T> = {
    promise: Promise<Response<T>>;
    abort: () => void;
};
export declare type Serializer = {
    parse?: (data: string) => any;
    convert?: (obj: any) => string;
};
