'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var common = require('@minireq/common');
var http = require('http');
var https = require('https');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () {
                        return e[k];
                    }
                });
            }
        });
    }
    n['default'] = e;
    return Object.freeze(n);
}

var http__namespace = /*#__PURE__*/_interopNamespace(http);
var https__namespace = /*#__PURE__*/_interopNamespace(https);

function makeRequest(serializers = common.defaultSerializers, defaultOptions = {}) {
    return function request(options) {
        var _a;
        const opts = Object.assign(Object.assign(Object.assign({}, common.defaults), defaultOptions), options);
        const url = opts.url + common.makeQueryString(opts.query);
        const h = /^http:\/\//.test(opts.url) ? http__namespace : https__namespace;
        if (opts.uploadProgress) {
            throw new Error('Node.js does not support reporting upload progress');
        }
        const headers = Object.assign({}, opts.headers);
        if (opts.contentType) {
            headers['Content-Type'] = opts.contentType;
        }
        if (opts.accept) {
            headers['Accept'] = opts.accept;
        }
        if (opts.auth) {
            const base64 = Buffer.from(opts.auth.user + ':' + opts.auth.password).toString('base64');
            headers.Authorization = `Basic ${base64}`;
        }
        let data = '';
        const req = h.request(url, {
            method: opts.method,
            timeout: opts.timeout,
            headers,
        });
        let id = undefined;
        if (opts.timeout) {
            id = setTimeout(() => {
                req.abort();
                if (opts.onTimeout) {
                    opts.onTimeout(makeProgress(data, undefined));
                }
            }, opts.timeout);
        }
        const promise = new Promise((resolve, reject) => {
            req.on('response', res => {
                if (opts.responseType !== 'binary') {
                    res.setEncoding('utf-8');
                }
                res.on('data', chunk => {
                    if (typeof chunk === 'string') {
                        data += chunk;
                    }
                    else {
                        if (data === '') {
                            data = [];
                        }
                        else {
                            data.push(chunk);
                        }
                    }
                    if (opts.progress) {
                        opts.progress(makeProgress(data, res.headers['content-length']));
                    }
                });
                res.on('end', () => {
                    var _a, _b;
                    if (id)
                        clearTimeout(id);
                    let response = data;
                    if (Array.isArray(data)) {
                        const buffer = Buffer.concat(data);
                        response = buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
                    }
                    if (typeof response === 'string' &&
                        opts.responseType === 'parsed') {
                        const mimeType = (_a = res.headers['content-type']) === null || _a === void 0 ? void 0 : _a.split(';')[0];
                        if (mimeType && ((_b = serializers[mimeType]) === null || _b === void 0 ? void 0 : _b.parse)) {
                            response = serializers[mimeType].parse(response);
                        }
                    }
                    resolve({
                        status: res.statusCode,
                        data: response,
                    });
                });
            });
            req.on('error', err => {
                if (!req.aborted) {
                    reject(err);
                }
            });
        });
        if (opts.send) {
            if (typeof opts.send === 'string' ||
                opts.send instanceof ArrayBuffer ||
                opts.send instanceof ArrayBuffer ||
                opts.send instanceof Int8Array ||
                opts.send instanceof Uint8Array ||
                opts.send instanceof Uint8ClampedArray ||
                opts.send instanceof Int16Array ||
                opts.send instanceof Uint16Array ||
                opts.send instanceof Int32Array ||
                opts.send instanceof Uint32Array ||
                opts.send instanceof Float32Array ||
                opts.send instanceof Float64Array ||
                opts.send instanceof DataView ||
                opts.send instanceof URLSearchParams) {
                req.write(opts.send);
            }
            else if ((_a = serializers[opts.contentType]) === null || _a === void 0 ? void 0 : _a.convert) {
                req.write(serializers[opts.contentType].convert(opts.send));
            }
            else {
                req.abort();
                throw new Error(`Could not find a serializer for content type ${opts.contentType}`);
            }
        }
        req.end();
        return {
            promise,
            abort: () => req.abort(),
        };
    };
}
function makeProgress(data, contentLength) {
    const lengthComputable = contentLength !== undefined;
    const loaded = typeof data === 'string'
        ? Buffer.byteLength(data)
        : data.reduce((acc, curr) => acc + curr.length, 0);
    let total = 0;
    if (lengthComputable) {
        total = parseInt(contentLength);
    }
    return {
        lengthComputable,
        loaded,
        total,
    };
}

exports.makeRequest = makeRequest;
